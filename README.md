Лабораторна робота №2: API для роботи з файлами та директоріями (Linux)

Мета роботи. Ознайомлення з низькорівневим файловим ввід-виводом у POSIX (Linux) та набуття практичних навичок створення консольних утиліт для роботи з файлами/каталогами. 


Зміст

Опис проєкту

Стек та стандарти

Структура репозиторію

Збирання та запуск

Завдання 1 — readbytes (аналог cat із позиційним читанням)

Завдання 2 — dir (спрощений аналог ls)

Завдання 3 — файл з «діркою» (необов’язкове)

Makefile: цілі та сценарії

Приклади сесій / скріншоти

Перевірка та тестування

Git-історія та .gitignore

Теорія (коротко)

Типові помилки та лайфхаки

Ліцензія

Опис проєкту

Репозиторій містить дві обов’язкові консольні утиліти:

readbytes — читає N байтів із вхідного файлу, починаючи з заданої позиції (офсета). Підтримує вивід у файл/STDOUT, допомогу та завершення виводу символом нового рядка. 



dir — спрощений аналог ls: друкує вміст каталогу з опціями -l (розширена інформація) та -a (показувати приховані). 


Обов’язкові вимоги: реалізовано Завдання №1 та Завдання №2, проєкт розбитий на кілька файлів, для кожного завдання є Makefile з цілями для побудови/очистки, код — під Git з адекватним .gitignore, у репозиторії ≥5 комітів; є цей README. 


Стек та стандарти

Мова: C (POSIX).

Заголовки/Системні виклики: unistd.h, fcntl.h, sys/stat.h, dirent.h, errno.h.

Інструменти: gcc, make, valgrind (опційно).

Стандарт компіляції: -std=c17 (або -std=c11) + -Wall -Wextra -Werror.

Структура репозиторію
.
├── readbytes/
│   ├── include/
│   │   └── readbytes.h
│   ├── src/
│   │   ├── main.c
│   │   ├── io.c           // open/read/write/close/lseek + обробка опцій
│   │   └── parse_args.c   // розбір CLI-аргументів
│   ├── Makefile
│   └── tests/
│       └── fixtures/...
├── dir/
│   ├── include/
│   │   └── dir.h
│   ├── src/
│   │   ├── main.c
│   │   ├── list.c         // opendir/readdir/stat/фільтри -a/-l
│   │   └── format.c       // форматування часу/прав/розміру
│   ├── Makefile
│   └── tests/
│       └── fixtures/...
├── common/
│   ├── include/
│   │   └── util.h         // спільні хелпери: помилки, друк usage, тощо
│   └── src/
│       └── util.c
├── .gitignore
├── README.md   // ви читаєте його :)
└── Makefile    // root-агрегатор: збирає обидві утиліти


Розбиття на модулі — вимога роботи (проєкт має складатися з декількох файлів). 


Збирання та запуск
Вимоги

Linux, gcc, make.

Швидкий старт (root Makefile)
# зібрати всі бінарники
make

# очищення (усі підпроєкти)
make clean

# повна перебудова
make rebuild

Збирання окремих утиліт
# readbytes
make -C readbytes

# dir
make -C dir

Де лежать бінарники

readbytes/build/readbytes

dir/build/dir

Завдання 1 — readbytes (аналог cat із позиційним читанням)

Призначення: зчитує певну кількість байтів із вхідного файлу, починаючи з вказаної позиції; виводить у STDOUT або у файл. Опційно завершує вивід символом нового рядка. 


Використання
readbytes [ОПЦІЇ] <input_file>

Опції:
  -h, --help            Показати довідку і завершити.
  -o, --output <file>   Записати результат у файл (інакше — STDOUT).
  -p, --position <N>    Почати читання з позиції N (байт, від початку). Якщо не вказано — з 0.
  -c, --count <K>       Прочитати K байтів. Якщо не вказано — до кінця файлу.
  -n, --newline         Додати '\n' після виводу.


Вимоги до опцій і поведінки прямо із завдання: -h, -o, -p, -c, -n; один позиційний аргумент — вхідний файл. 


Приклади
# 1) Прочитати весь файл у STDOUT
readbytes ./data/lorem.txt

# 2) Прочитати 100 байтів, починаючи з позиції 10
readbytes -p 10 -c 100 ./data/lorem.txt

# 3) Прочитане записати у файл і додати новий рядок
readbytes -c 64 -o out.bin -n ./data/raw.bin

# 4) Довідка
readbytes -h

Реалізаційні деталі

Відкриття файлу: open(path, O_RDONLY); помилки через errno.

Якщо задано -p, перед читанням: lseek(fd, pos, SEEK_SET).

Читання циклом read() у буфер фіксованого розміру (наприклад, 4–8 КБ) до виконання умови count або EOF.

Вивід: у файл (open(..., O_CREAT|O_TRUNC|O_WRONLY, 0644)) або STDOUT_FILENO.

По завершенні опційно друкуємо '\n' для --newline.

Усюди — акуратна перевірка read()/write()/lseek()/close() на помилки.

Використані саме низькорівневі системні виклики (open/read/write/lseek/close) згідно з теоретичною частиною. 


Завдання 2 — dir (спрощений аналог ls)

Призначення: виводить вміст каталогу. За замовчуванням — поточний каталог. Підтримує: -h/--help, -l/--long (додаткова інформація), -a/--all (показувати приховані). 

Використання
dir [ОПЦІЇ] [DIR]

Опції:
  -h, --help   Показати довідку і завершити.
  -l, --long   Розширений формат (тип, права, лінки, власник/група, розмір, mtime).
  -a, --all    Показувати приховані елементи (імена, що починаються з '.').

Приклади
# 1) Поточний каталог (без прихованих, короткий формат)
dir

# 2) Вказаний каталог у розширеному форматі
dir -l /var/log

# 3) Усе (включно з прихованими) у розширеному форматі
dir -la ~/projects

Реалізаційні деталі

Перелік елементів: opendir()/readdir(); пропускаємо . і .. за потреби.

При -a показуємо імена, що починаються з ..

Для -l викликаємо lstat()/stat() і форматуємо:

тип (S_ISREG, S_ISDIR, S_ISLNK, …), права доступу (st_mode),

кількість лінків (st_nlink), власник (st_uid)/група (st_gid),

розмір (st_size), час модифікації (st_mtime). 


Форматування прав у стилі rwxr-xr--, типу (-, d, l), дати — за допомогою localtime()/strftime().

Завдання 3 — файл з «діркою» (необов’язкове)

Ідея: створити текстовий файл, записати рядок, потім перемістити поточну позицію за межі кінця файлу (lseek(..., SEEK_END) + offset) і записати ще одну порцію даних. Утвориться file hole — область, що логічно існує в середині файлу, але не займає місця на диску (читання з неї повертає нуль-байти). Перевірити cat, od -c, ls -ls vs ls -lsh. 


Підказка запуску:

./build/mkhole ./file.hole "BEGIN\n" 1048576 "END\n"  # відступ 1 МБ
cat file.hole
od -c file.hole | head
ls -ls file.hole   # виділені блоки
ls -lsh file.hole  # «людяний» розмір
